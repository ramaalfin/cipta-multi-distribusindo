<template>
    <div class="hyper-popover" v-click-outside="clickOutsideHandler">
        <div id="element" ref="hyper-element">
            <slot name="element" />
        </div>

        <!-- tabindex necessary to be able to focus on this div => Use for click outside detection -->
        <div id="menu" ref="hyper-menu" :style="{ zIndex }" :class="type" tabindex="-1">
            <hy-section :style="{ minWidth }">
                <slot name="popover" />
            </hy-section>

            <div id="arrow" data-popper-arrow></div>
        </div>
    </div>
</template>

<script>
import * as Popper from "@popperjs/core";
import vClickOutside from "click-outside-vue3";
import HySection from "./Section.vue";

export default {
    name: "HyPopover",
    emits: ["update:modelValue"],
    props: {
        modelValue: {
            type: Boolean,
            required: true,
        },
        hover: {
            type: Boolean,
            default: false,
        },
        hoverDelay: {
            type: Number,
            default: 700,
        },
        hideOnClickOutside: {
            type: Boolean,
            default: true,
        },
        minWidth: {
            type: String,
            default: "0",
        },
        type: {
            type: String,
            default: "same",
        },
        zIndex: {
            type: Number,
            default: 10,
        },
        placement: {
            type: String,
            default: "bottom",
        },
        offsetY: {
            type: Number,
            default: 15,
        },
        offsetX: {
            type: Number,
            default: 0,
        },
    },
    data() {
        return {
            popper: null,
            menu: null,
            element: null,
            isHovering: false,
        };
    },
    computed: {
        popperOptions() {
            return {
                modifiers: [
                    {
                        name: "offset",
                        options: {
                            offset: [this.offsetX, this.offsetY], // 0, 15
                        },
                    },
                    {
                        name: "preventOverflow",
                        options: {
                            padding: 20,
                        },
                    },
                ],
                placement: this.placement,
            };
        },
    },
    watch: {
        modelValue() {
            if (this.modelValue == true) this.show();
            else this.hide();
        },
    },
    methods: {
        show() {
            this.menu.setAttribute("data-show", "");

            this.popper.setOptions((options) => ({
                ...options,
                modifiers: [...options.modifiers, { name: "eventListeners", enabled: true }],
            }));

            this.popper.update();
        },
        hide() {
            this.menu.removeAttribute("data-show");

            this.popper.setOptions((options) => ({
                ...options,
                modifiers: [...options.modifiers, { name: "eventListeners", enabled: false }],
            }));
        },
        clickOutsideHandler() {
            // For some reason this method is called every time a click occurs, but only emits if the click is outside
            // console.log("click");
            if (this.hideOnClickOutside == false) return;

            this.isHovering = false;
            this.$emit("update:modelValue", false);
        },
    },
    mounted() {
        this.menu = this.$refs["hyper-menu"];
        this.element = this.$refs["hyper-element"];

        // Create popper instance
        this.popper = Popper.createPopper(this.element, this.menu, this.popperOptions);

        // Open and close on mouse hover
        if (this.hover == false) return;

        [this.element, this.menu].forEach((el) => {
            el.addEventListener("mouseenter", () => {
                this.isHovering = true;

                setTimeout(() => {
                    if (this.isHovering == false) return;

                    this.$emit("update:modelValue", true);
                }, this.hoverDelay);
            });

            el.addEventListener("mouseleave", () => {
                this.isHovering = false;

                setTimeout(() => {
                    if (this.isHovering == true) return;

                    this.$emit("update:modelValue", false);
                }, this.hoverDelay);
            });
        });
    },
    beforeUnmount() {
        this.hide();
        this.popper.destroy();
        this.popper = null;
    },
    directives: {
        clickOutside: vClickOutside.directive,
    },
    components: {
        HySection,
    },
};
</script>

<style lang="scss">
.hyper-popover {
    margin: var(--element-margin);

    #element {
        & > *:first-child {
            margin-top: 0;
        }

        & > *:last-child {
            margin-bottom: 0;
        }
    }

    #menu {
        max-width: calc(100vw - 40px);

        opacity: 0;
        pointer-events: none;
        transition: var(--element-transition);
        transition-property: opacity;
        transition-duration: 0.1s;

        // Arrow won't be shown without this
        border-radius: var(--section-border-radius);

        &[data-show] {
            opacity: 1;
            pointer-events: all;
        }

        // Different color types
        &.same {
            &,
            .hyper-section {
                background-color: var(--popover-bg-color-same);
                color: var(--font-color-dark);
            }
        }

        &.contrast {
            &,
            .hyper-section {
                background-color: var(--popover-bg-color-contrast);
                color: var(--font-color-bright);
            }
        }

        .hyper-section {
            box-shadow: var(--popover-shadow);
            padding: var(--element-padding);
            margin: 0;
        }

        #arrow,
        #arrow::before {
            position: absolute;
            width: 12px;
            height: 12px;
            background: inherit;
        }

        #arrow {
            visibility: hidden;
        }

        #arrow::before {
            visibility: visible;
            content: "";
            transform: rotate(45deg);
        }

        &[data-popper-placement^="top"] > #arrow {
            bottom: -6px;
        }

        &[data-popper-placement^="bottom"] > #arrow {
            top: -6px;
        }

        &[data-popper-placement^="left"] > #arrow {
            right: -6px;
        }

        &[data-popper-placement^="right"] > #arrow {
            left: -6px;
        }
    }
}
</style>
